using inSyca.foundation.integration.biztalk.components.diagnostics;
using Microsoft.BizTalk.Component;
using Microsoft.BizTalk.Component.Interop;
using Microsoft.BizTalk.Message.Interop;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Reflection;
using System.Text;
using System.Xml.Linq;

namespace inSyca.foundation.integration.biztalk.components
{
    [ComponentCategory(CategoryTypes.CATID_PipelineComponent)]
    [ComponentCategory(CategoryTypes.CATID_DisassemblingParser)]
    [System.Runtime.InteropServices.Guid("5C03C3D5-BCBA-44C4-A148-A5A84EA49D94")]
    public class ReflectionDisassembler : FFDasmComp, IBaseComponent, IComponentUI, IDisassemblerComponent, IPersistPropertyBag, IProbeMessage
    {
        /// <summary>
        /// this variable will contain any message generated by the Disassemble method
        /// </summary>
        private Queue _msgs = new Queue();

        #region Properties

        public new string DocumentSpecName
        {
            get
            {
                return "NoSchema";
            }
            set
            {
                ;
            }
        }

        [Description("classname with namespace")]
        [DisplayName("ClassName")]
        public string ClassName { get; set; }

        [Description("method to invoke")]
        [DisplayName("MethodName")]
        public string MethodName { get; set; }
        #endregion

        #region IBaseComponent
        public new string Description
        {
            get
            {
                return "ReflectionDisassembler";
            }
        }

        public new string Name
        {
            get
            {
                return "ReflectionDisassembler";
            }
        }

        public new string Version
        {
            get
            {
                return "1.0.0.0";
            }
        }
        #endregion

        #region IPersistPropertyBag

        public new void GetClassID(out Guid classID)
        {
            classID = new Guid("5C03C3D5-BCBA-44C4-A148-A5A84EA49D94");
        }

        public new void InitNew()
        {
            Log.InfoFormat("InitNew()");
        }

		public new void Load(IPropertyBag propertyBag, int errorLog)
        {
            Log.InfoFormat("Load(IPropertyBag propertyBag, int errorLog)");

            using (DisposableObjectWrapper wrapper = new DisposableObjectWrapper(propertyBag))
            {
                object val = null;

                val = PropertyHelper.ReadPropertyBag(propertyBag, "ClassName");

                if (val != null)
                    ClassName = (string)val;

                val = PropertyHelper.ReadPropertyBag(propertyBag, "MethodName");

                if (val != null)
                    MethodName = (string)val;
            }

            Log.DebugFormat("Load ClassName {0}", ClassName);
            Log.DebugFormat("Load MethodName {0}", MethodName);
        }

        public new void Save(IPropertyBag propertyBag, bool clearDirty, bool saveAllProperties)
        {
            Log.InfoFormat("Save(IPropertyBag propertyBag, bool clearDirty, bool saveAllProperties)");

            using (DisposableObjectWrapper wrapper = new DisposableObjectWrapper(propertyBag))
            {
                object val = null;

                val = ClassName;
                propertyBag.Write("ClassName", ref val);

                val = MethodName;
                propertyBag.Write("MethodName", ref val);
            }

            Log.DebugFormat("Save ClassName {0}", ClassName);
            Log.DebugFormat("Save MethodName {0}", MethodName);
        }

        #endregion

        #region IComponentUI members
        /// <summary>
        /// Component icon to use in BizTalk Editor
        /// </summary>
        new public IntPtr Icon
        {
            get
            {
                return Properties.Resources.cog.Handle;
            }
        }

        /// <summary>
        /// The Validate method is called by the BizTalk Editor during the build 
        /// of a BizTalk project.
        /// </summary>
        /// <param name="obj">An Object containing the configuration properties.</param>
        /// <returns>The IEnumerator enables the caller to enumerate through a collection of strings containing error messages. These error messages appear as compiler error messages. To report successful property validation, the method should return an empty enumerator.</returns>
        public new IEnumerator Validate(object obj)
        {
            Log.InfoFormat("Validate(object obj)");
            return null;
        }

        #endregion

        #region IProbeMessage Members

        public new bool Probe(IPipelineContext pContext, IBaseMessage pInMsg)
        {
            Log.InfoFormat("Probe(IPipelineContext pContext, IBaseMessage pInMsg)");
            return true;
        }

        #endregion

        #region IDisassemblerComponent members

        /// <summary>
        /// Returns messages resulting from the disassemble method execution
        /// </summary>
        /// <param name="pipelineContext">the pipeline context</param>
        /// <returns></returns>
        public new IBaseMessage GetNext(IPipelineContext pipelineContext)
        {
            // get the next message from the Queue and return it
            IBaseMessage msg = null;
            if (_msgs.Count > 0)
            {
                msg = ((IBaseMessage)(_msgs.Dequeue()));

                return msg;
            }
            else
            {
                return msg;
            }
        }

        /// <summary>
        /// called by the messaging engine when a new message arrives
        /// </summary>
        /// <param name="pipelineContext">the pipeline context</param>
        /// <param name="inMsg">the actual message</param>
        public new void Disassemble(IPipelineContext pipelineContext, IBaseMessage inMsg)
        {
            Log.InfoFormat("Disassemble(IPipelineContext pipelineContext, IBaseMessage inMsg)");

            List<XElement> xElementMessages;
            TransformMessage(inMsg.BodyPart.Data, out xElementMessages);

            Log.InfoFormat("xElementMessages.Count {0}", xElementMessages.Count);

            foreach (var xElementMessage in xElementMessages)
            {
                Log.InfoFormat("foreach (var xElementMessage in xElementMessages)");

                IBaseMessage outMsg;
                outMsg = pipelineContext.GetMessageFactory().CreateMessage();

                for (int j = 0; j < inMsg.Context.CountProperties; j++)
                {

                    string currentName;
                    string currentNamespace;
                    object obj = inMsg.Context.ReadAt(j, out currentName, out currentNamespace);
                    outMsg.Context.Write(currentName, currentNamespace, obj);

                    if (inMsg.Context.IsPromoted(currentName, currentNamespace))
                    {
                        outMsg.Context.Promote(currentName, currentNamespace, obj);
                    }
                }

                outMsg.Context.Promote("MessageType", "http://schemas.microsoft.com/BizTalk/2003/system-properties", string.Format("{0}#{1}", xElementMessage.GetNamespaceOfPrefix("ns0"), xElementMessage.Name.LocalName));

                Log.InfoFormat("Calling Encoding.UTF8.GetBytes(xElementMessage.ToString())");

                byte[] byteArray = Encoding.UTF8.GetBytes(xElementMessage.ToString());
                Stream ms = new MemoryStream(byteArray);
                ms.Seek(0, SeekOrigin.Begin);

                Log.InfoFormat("Assemble Out Message");

                outMsg.AddPart("Body", pipelineContext.GetMessageFactory().CreateMessagePart(), true);
                outMsg.BodyPart.Data = ms;

                Log.InfoFormat("Calling _msgs.Enqueue(outMsg)");

                _msgs.Enqueue(outMsg);
            }
        }
        #endregion

        #region Helper function
        /// <summary>
        /// Transforms XML message in input stream to HTML message
        /// </summary>
        /// <param name="stream">Stream with input XML message</param>
        /// <param name="xElementMessages"></param>
        /// <returns>Stream with output HTML message</returns>
        public bool TransformMessage(Stream stream, out List<XElement> xElementMessages)
        {
            xElementMessages = new List<XElement>();
            bool returnValue = false;

            try
            {
                Assembly assememblyUtil = typeof(ReflectionDisassembler).Assembly;

                Type typeUtil = assememblyUtil.GetType(ClassName);

                object objectUtil = Activator.CreateInstance(typeUtil);

                MethodInfo methodTransformMessage = typeUtil.GetMethod(MethodName);

                object[] parametersTransformMessage = new object[] { stream, xElementMessages };

                returnValue = Convert.ToBoolean(methodTransformMessage.Invoke(objectUtil, parametersTransformMessage));
            }
            catch (Exception ex)
            {
                returnValue = false;
                Log.Error("TransformMessage call failed", ex);
            }

            return returnValue;

        }

        #endregion

    }
}